#include "DIYModule.h"
#include "MeshService.h"
#include "Router.h"

// Allow these static members to be used here in method definitions
char *DIYModule::currentText;
char *DIYModule::requestedArg;

// Container of all classes derived from DIYModule
std::vector<DIYModule *> *DIYModule::diyModules;

static bool argMemoryAllocated = false;

DIYModule::DIYModule(const char *_name, ControlStyle style) : MeshModule(_name), style(style)
{
    // Add this module instance to the vector
    if (!diyModules)
        diyModules = new std::vector<DIYModule *>();
    diyModules->push_back(this);

    // If controlling with a dedicated channel, create a channel name string, capped at 11 chars
    if (style == OWN_CHANNEL) {
        strncpy(ownChannelName, name, 11);
    }
}

ProcessMessage DIYModule::interceptSentText(meshtastic_MeshPacket &mp, RxSource src)
{
    if (src != RX_SRC_USER) {
        LOG_DEBUG("Intercept: ignoring, not generated by user\n");
        return ProcessMessage::CONTINUE;
    }

    if (mp.decoded.portnum != meshtastic_PortNum_TEXT_MESSAGE_APP) {
        LOG_DEBUG("Intercept: ignoring, only interested in text\n");
        return ProcessMessage::CONTINUE;
    }

    currentText = new char[mp.decoded.payload.size + 1]; // +1 for null term
    strcpy(currentText, (char *)mp.decoded.payload.bytes);

    bool intercepted = false;

    // For each module
    for (auto i = diyModules->begin(); i != diyModules->end(); ++i) {
        auto &cm = **i;

        // Decide if current module wants this input
        bool moduleWantsText = false;
        if (cm.style == BY_NAME && stringsMatch(getArg(0), cm.name, false)) // Global command
            moduleWantsText = true;
        else if (cm.style == OWN_CHANNEL && isFromChannel(mp, cm.ownChannelName)) // Own channel
            moduleWantsText = true;

        // If module wants text
        if (moduleWantsText) {
            // Let the module handle it
            cm.handleSentText(mp);

            // Cancel the message, and lie to the phone that it was sent successfully
            service.cancelSending(mp.id);
            meshtastic_QueueStatus qs = router->getQueueStatus();
            ErrorCode r = service.sendQueueStatusToPhone(qs, meshtastic_Routing_Error_NONE, mp.id);
            if (r != ERRNO_OK)
                LOG_DEBUG("DIYModule can't send status to phone");

            intercepted = true;
            break;
        }
    }

    delete[] currentText;

    if (argMemoryAllocated) {
        delete[] requestedArg;
        argMemoryAllocated = false;
    }

    return intercepted ? ProcessMessage::STOP : ProcessMessage::CONTINUE;
}

void DIYModule::sendPhoneFeedback(const char *text, const char *channelName)
{
    meshtastic_Channel feedbackChannel;
    if (style == BY_NAME)
        feedbackChannel = channels.getByName(channelName);
    else                                                      // OWN_CHANNEL
        feedbackChannel = channels.getByName(ownChannelName); // module name

    meshtastic_MeshPacket *feedback = router->allocForSending();
    feedback->to = myNodeInfo.my_node_num;
    feedback->from = NODENUM_BROADCAST;
    feedback->channel = feedbackChannel.index;
    feedback->decoded.portnum = meshtastic_PortNum_TEXT_MESSAGE_APP;
    feedback->decoded.payload.size = strlen(text);
    memcpy(feedback->decoded.payload.bytes, text, feedback->decoded.payload.size);

    LOG_DEBUG("Sent feedback to phone: \"%s\"\n", text);
    service.sendToPhone(feedback);
}

bool DIYModule::channelExists(const char *channelName)
{
    int8_t allegedIndex = channels.getByName(channelName).index;
    return strcmp(channels.getByIndex(allegedIndex).settings.name, channelName) == 0; // Did getByName() find the correct channel?
}

bool DIYModule::isFromChannel(const meshtastic_MeshPacket &mp, const char *channelName)
{
    return strcmp(channelName, channels.getByIndex(mp.channel).settings.name) == 0; // Compare names only
}

bool DIYModule::isFromPublicChannel(const meshtastic_MeshPacket &mp)
{
    return isFromChannel(mp, "");
}

const char *DIYModule::getChannelName(const meshtastic_MeshPacket &mp)
{
    return channels.getByIndex(mp.channel).settings.name;
}

bool DIYModule::parseBool(const char *raw)
{
    return stringsMatch(raw, "true", false);
}

bool DIYModule::stringsMatch(const char *s1, const char *s2, bool caseSensitive)
{
    if (strlen(s1) != strlen(s2))
        return false;

    for (uint16_t i = 0; i <= strlen(s1); i++) {
        if (caseSensitive && s1[i] != s2[i])
            return false;
        if (!caseSensitive && tolower(s1[i]) != tolower(s2[i]))
            return false;
    }

    return true;
}

char *DIYModule::getArg(uint8_t index, bool untilEnd)
{
    // Free the existing memory, if still in use
    if (argMemoryAllocated) {
        delete[] requestedArg;
        argMemoryAllocated = false;
    }

    // Handle an empty string separately - save headaches
    if (strlen(currentText) == 0) {
        requestedArg = new char[1];
        argMemoryAllocated = true;
        requestedArg[0] = '\0';
        return requestedArg;
    }

    // Find start and end index of our substring
    constexpr char delimiter = ' ';
    uint8_t delimiterCount = 0;
    uint8_t start = 0;
    uint8_t end = 0;

    for (uint16_t i = 0;; i++) {
        // Null term
        if (currentText[i] == '\0') {
            end = i - 1; // Exclude the null term here, just to stay consistent
            break;       // Found the end
        }

        // Delimiter
        if (currentText[i] == delimiter) {
            delimiterCount++;
            if (delimiterCount == index)
                start = i + 1;

            if (delimiterCount == index + 1 && !untilEnd) {
                end = i - 1;
                break; // Found the end
            }
        }
    }

    // If we found an argument and the requested index
    if (delimiterCount >= index) {
        uint8_t substringLength = (end - start) + 1;  // +1 "arrays start at zero"
        requestedArg = new char[substringLength + 1]; // + 1 for terminator
        argMemoryAllocated = true;
        strncpy(requestedArg, currentText + start, substringLength); // Copy the substring (no null term)
        requestedArg[substringLength] = '\0';                        // Append null term
    }
    // If the index exceed the number of arguments parsed
    else {
        requestedArg = new char[1];
        requestedArg[0] = '\0';
    }

    return requestedArg; // Really just for convenience. We always return requestedArg
}

uint32_t DIYModule::getDataHash(void *data, uint32_t size)
{
    uint32_t hash = 0;

    // Sum all bytes of the image buffer together
    for (uint32_t i = 0; i < size; i++)
        hash += ((uint8_t *)data)[i];

    return hash;
}

// void DIYModule::loadData(uint8_t *dest, uint32_t size)
// {
//     // Build the filepath using the module's name
//     String filename = saveDirectory;
//     filename += "/";
//     filename += name;
//     filename += ".data";

// #ifdef FSCom

//     // Check that the file *does* actually exist
//     if (!FSCom.exists(filename)) {
//         LOG_INFO("'%s' not found. Using default values\n", filename);
//         // Todo: init struct
//         return;
//     }

//     // Open the file
//     auto f = FSCom.open(filename, FILE_O_READ);

//     // If opened, start reading
//     if (f) {
//         LOG_INFO("Loading DIY module data '%s'\n", filename.c_str());

//         // Read the actual data
//         f.readBytes((char *)dest, size);

//         // Read the hash
//         uint32_t savedHash = 0;
//         f.readBytes((char *)&savedHash, sizeof(savedHash));

//         // Calculate hash of the loaded data, then compare with the saved hash
//         uint32_t calculatedHash = getDataHash(dest, size);
//         if (savedHash != calculatedHash) {
//             LOG_WARN("'%s' is corrupt (hash mismatch). Using default values\n");
//             // Todo: init with default values
//         }

//         f.close();
//     } else {
//         LOG_ERROR("Could not open / read %s\n", filename);
//     }
// #else
//     LOG_ERROR("ERROR: Filesystem not implemented\n");
//     state = LoadFileState::NO_FILESYSTEM;
// #endif
//     return;
// }

// uint32_t DIYModule::getDataHash(uint8_t *data, uint32_t size)
// {
//     uint32_t hash = 0;

//     // Sum all bytes of the image buffer together
//     for (uint32_t i = 0; i < size; i++)
//         hash += data[i];

//     return hash;
// }

// bool DIYModule::saveData(uint8_t *data, uint32_t size)
// {
//     // Build the filepath using the module's name
//     String filename = saveDirectory;
//     filename += "/";
//     filename += name;
//     filename += ".data";

// #ifdef FSCom
//     // Make the directory, if it doesn't exist
//     if (!FSCom.exists(saveDirectory))
//         FSCom.mkdir(saveDirectory);

//     // Create a temporary filename, where we will write data, then later rename
//     String filenameTmp = filename;
//     filenameTmp += ".tmp";

//     // Open the file
//     auto f = FSCom.open(filenameTmp.c_str(), FILE_O_WRITE);

//     // If it opened, start writing
//     if (f) {
//         // Calculate a hash of the data
//         uint32_t hash = getDataHash((uint8_t *)data, size);

//         f.write((uint8_t *)data, size);          // Write the actualy data
//         f.write((uint8_t *)&hash, sizeof(hash)); // Append the hash

//         f.flush();
//         f.close();

//         // Remove the old file (brief window of risk here()
//         if (FSCom.exists(filename) && !FSCom.remove(filename)) {
//             LOG_WARN("Can't remove old DIY module file\n");
//         }

//         // Rename the new (temporary) file to take place of the old
//         if (!renameFile(filenameTmp.c_str(), filename.c_str())) {
//             LOG_ERROR("Error: can't rename new  DIY module file\n");
//         }
//     } else {
//         LOG_ERROR("Can't write DIY module file\n");
// #ifdef ARCH_NRF52
//         static uint8_t failedCounter = 0;
//         failedCounter++;
//         if (failedCounter >= 2) {
//             LOG_ERROR("Failed to save DIY module file twice. Rebooting...\n");
//             delay(100);
//             NVIC_SystemReset();
//         } else
//             saveConfig(); // Recurse
// #endif
//     }
// #else
//     LOG_ERROR("ERROR: Filesystem not implemented\n");
// #endif
// }